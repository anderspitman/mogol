(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["golicons"] = factory();
	else
		root["golicons"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/core.js":
/*!*********************!*\
  !*** ./src/core.js ***!
  \*********************/
/*! exports provided: GOL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GOL\", function() { return GOL; });\nconst SVG_NS = 'http://www.w3.org/2000/svg';\n\nconsole.log(\"Hi there\");\n\nfunction parsePattern(patternText) {\n  const rows = [];\n  for (let line of patternText.split('\\n')) {\n\n    line = line.trim();\n\n    if (line === '') {\n      continue;\n    }\n\n    const row = [];\n    rows.push(row);\n    \n    for (const char of line) {\n      let cell;\n      if (char === '.') {\n        cell = 0;\n      }\n      else if (char === 'O') {\n        cell = 1;\n      }\n      else {\n        throw \"Error parsing pattern char: \" + char;\n      }\n\n      row.push(cell);\n    }\n  }\n\n  return rows;\n}\n\n\nclass GOL {\n  constructor(el) {\n    this._el = el;\n\n    this._tickDelayMs = 1000;\n\n    this._parseClassOptions();\n\n    this._state = this._patternFunc(); \n    this._newState = this._patternFunc(); \n    this._prevState = this._patternFunc();\n    this._cells = [];\n\n    this._numRows = this._state.length;\n    this._numCols = this._state[0].length;\n\n    const dim = el.getBoundingClientRect();\n    const cellWidth = dim.width / this._numCols;\n    const cellHeight = dim.height / this._numRows;\n\n    const svg = document.createElementNS(SVG_NS, 'svg');\n    svg.style.width = '100%';\n    svg.style.height = '100%';\n    el.appendChild(svg);\n    \n    for (let i = 0; i < this._state.length; i++) {\n      const row = document.createElementNS(SVG_NS, 'g');\n      this._cells[i] = [];\n      row.classList.add('goli-row');\n      row.setAttribute('transform', 'translate(0, ' + i*cellHeight + ')');\n      svg.appendChild(row);\n      for (let j = 0; j < this._state[0].length; j++) {\n        const cell = document.createElementNS(SVG_NS, 'rect');\n        cell.setAttribute('width', cellWidth);\n        cell.setAttribute('height', cellHeight);\n        cell.setAttribute('x', j*cellWidth);\n        row.appendChild(cell);\n        this._cells[i][j] = cell;\n      }\n    }\n\n    this.initRender();\n  }\n\n  _parseClassOptions() {\n    const classList = this._el.classList;\n\n    for (const klass of classList) {\n      if (klass.startsWith('goli-tick-ms')) {\n        this._tickDelayMs = Number(klass.slice(13));\n      }\n      else if (klass.startsWith('goli-start-delay-ms')) {\n        this._startDelayMs = Number(klass.slice(20));\n      }\n      else {\n        // class not recognized; check if there's a plugin for it\n        if (names[klass]) {\n          names[klass](this);\n        }\n        else if (klass.startsWith('goli-')) {\n          throw \"Unrecognized golicons class: \" + klass;\n        }\n      }\n    }\n  }\n\n  setPatternFunc(func) {\n    this._patternFunc = func;\n  }\n  \n  start() {\n    const go = () => {\n      setInterval(() => {\n        this.tick();\n        //requestAnimationFrame(this.render.bind(this));\n        this.render();\n      }, this._tickDelayMs);\n    };\n\n    if (!this._startDelayMs) {\n      go();\n    }\n    else {\n      setTimeout(go, this._startDelayMs);\n    }\n  }\n\n  printState() {\n    for (let i = 0; i < this._state.length; i++) {\n      const row = this._state[i];\n      console.log(JSON.stringify(row), i);\n    }\n    console.log();\n  }\n\n  tick() {\n    //const startTime = timeNowSeconds();\n\n    copyState(this._state, this._newState);\n    copyState(this._state, this._prevState);\n\n    for (let i = 0; i < this._state.length; i++) {\n      for (let j = 0; j < this._state[0].length; j++) {\n        const neighbors = this.neighbors(i, j);\n\n        let liveCount = 0;\n\n        // TODO: this can be generated on the fly in neighbors\n        for (const neighbor of neighbors) {\n          if (neighbor === 1) {\n            liveCount++;\n          }\n        }\n\n        const currentState = this._state[i][j];\n        let newState = currentState;\n        if (currentState === 1) {\n          if (liveCount < 2) {\n            // underpopulation\n            newState = 0;\n          }\n          else if (liveCount > 3) {\n            // overpopulation\n            newState = 0;\n          }\n          else {\n            // stays live\n            newState = 1;\n          }\n        }\n        else {\n          if (liveCount === 3) {\n            // reproduction\n            newState = 1;\n          }\n        }\n\n        this._newState[i][j] = newState;\n      }\n    }\n\n    copyState(this._newState, this._state);\n\n    //console.log(\"Tick time: \" + (timeNowSeconds() - startTime));\n  }\n\n  neighbors(i, j) {\n    // TODO: get rid of this allocation\n    const n = [];\n    n.push(this.topLeft(i, j));\n    n.push(this.top(i, j));\n    n.push(this.topRight(i, j));\n    n.push(this.left(i, j));\n    n.push(this.right(i, j));\n    n.push(this.bottomLeft(i, j));\n    n.push(this.bottom(i, j));\n    n.push(this.bottomRight(i, j));\n    return n;\n  }\n\n  wrapTop(i) {\n    if (i === 0) {\n      return this._state.length - 1;\n    }\n    return i - 1;\n  }\n\n  wrapLeft(j) {\n    if (j === 0) {\n      return this._state[0].length - 1;\n    }\n    return j - 1;\n  }\n\n  wrapRight(j) {\n    if (j === this._state[0].length - 1) {\n      return 0;\n    }\n    return j + 1;\n  }\n\n  wrapBottom(i) {\n    if (i === this._state.length - 1) {\n      return 0;\n    }\n    return i + 1;\n  }\n\n  topLeft(i, j) {\n    return this._state[this.wrapTop(i)][this.wrapLeft(j)];\n  }\n\n  top(i, j) {\n    return this._state[this.wrapTop(i)][j];\n  }\n\n  topRight(i, j) {\n    return this._state[this.wrapTop(i)][this.wrapRight(j)];\n  }\n\n  left(i, j) {\n    return this._state[i][this.wrapLeft(j)];\n  }\n\n  right(i, j) {\n    return this._state[i][this.wrapRight(j)];\n  }\n\n  bottomLeft(i, j) {\n    return this._state[this.wrapBottom(i)][this.wrapLeft(j)];\n  }\n\n  bottom(i, j) {\n    return this._state[this.wrapBottom(i)][j];\n  }\n\n  bottomRight(i, j) {\n    return this._state[this.wrapBottom(i)][this.wrapRight(j)];\n  }\n\n  // don't check if value changed on first render\n  initRender() {\n    for (let i = 0; i < this._numRows; i++) {\n      for (let j = 0; j < this._numCols; j++) {\n          this.renderCell(i, j, this._state[i][j]);\n      }\n    }\n  }\n\n  render() {\n    //const startTime = timeNowSeconds();\n\n    for (let i = 0; i < this._numRows; i++) {\n      for (let j = 0; j < this._numCols; j++) {\n        if (this._state[i][j] !== this._prevState[i][j]) {\n          this.renderCell(i, j, this._state[i][j]);\n        }\n      }\n    }\n\n    //console.log(\"Render time: \" + (timeNowSeconds() - startTime));\n  }\n\n  renderCell(i, j, state) {\n    if (state === 1) {\n      this._cells[i][j].classList.remove('goli-dead');\n      this._cells[i][j].classList.add('goli-live');\n    }\n    else {\n      this._cells[i][j].classList.remove('goli-live');\n      this._cells[i][j].classList.add('goli-dead');\n    }\n  }\n}\n\nfunction copyState(a, b) {\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < a[0].length; j++) {\n      b[i][j] = a[i][j];\n    }\n  }\n}\n\nfunction timeNowSeconds() {\n  return performance.now() / 1000;\n}\n\n\n//# sourceURL=webpack://golicons/./src/core.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: GOL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./src/core.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GOL\", function() { return _core__WEBPACK_IMPORTED_MODULE_0__[\"GOL\"]; });\n\n//import { start, registerPattern } from './core';\n//import {\n//  blinkerText,\n//  beaconText,\n//  toadText,\n//  gliderText,\n//} from './patterns';\n\n\n\n\n//# sourceURL=webpack://golicons/./src/index.js?");

/***/ })

/******/ });
});